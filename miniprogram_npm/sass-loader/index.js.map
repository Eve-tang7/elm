{"version":3,"sources":["cjs.js","index.js","options.json","utils.js","SassError.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst loader = require(\"./index\");\n\nmodule.exports = loader.default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _utils = require(\"./utils\");\n\nvar _SassError = _interopRequireDefault(require(\"./SassError\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The sass-loader makes node-sass and dart-sass available to webpack modules.\n *\n * @this {object}\n * @param {string} content\n */\nasync function loader(content) {\n  const options = this.getOptions(_options.default);\n  const callback = this.async();\n  const implementation = (0, _utils.getSassImplementation)(this, options.implementation);\n\n  if (!implementation) {\n    callback();\n    return;\n  }\n\n  const useSourceMap = typeof options.sourceMap === \"boolean\" ? options.sourceMap : this.sourceMap;\n  const sassOptions = await (0, _utils.getSassOptions)(this, options, content, implementation, useSourceMap);\n  const shouldUseWebpackImporter = typeof options.webpackImporter === \"boolean\" ? options.webpackImporter : true;\n\n  if (shouldUseWebpackImporter) {\n    const {\n      includePaths\n    } = sassOptions;\n    sassOptions.importer.push((0, _utils.getWebpackImporter)(this, implementation, includePaths));\n  }\n\n  const render = (0, _utils.getRenderFunctionFromSassImplementation)(implementation);\n  render(sassOptions, (error, result) => {\n    if (error) {\n      // There are situations when the `file` property do not exist\n      if (error.file) {\n        // `node-sass` returns POSIX paths\n        this.addDependency(_path.default.normalize(error.file));\n      }\n\n      callback(new _SassError.default(error));\n      return;\n    }\n\n    let map = result.map ? JSON.parse(result.map) : null; // Modify source paths only for webpack, otherwise we do nothing\n\n    if (map && useSourceMap) {\n      map = (0, _utils.normalizeSourceMap)(map, this.rootContext);\n    }\n\n    result.stats.includedFiles.forEach(includedFile => {\n      const normalizedIncludedFile = _path.default.normalize(includedFile); // Custom `importer` can return only `contents` so includedFile will be relative\n\n\n      if (_path.default.isAbsolute(normalizedIncludedFile)) {\n        this.addDependency(normalizedIncludedFile);\n      }\n    });\n    callback(null, result.css.toString(), map);\n  });\n}\n\nvar _default = loader;\nexports.default = _default;","module.exports = {\n  \"title\": \"Sass Loader options\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"implementation\": {\n      \"description\": \"The implementation of the sass to be used (https://github.com/webpack-contrib/sass-loader#implementation).\",\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"object\"\n        }\n      ]\n    },\n    \"sassOptions\": {\n      \"description\": \"Options for `node-sass` or `sass` (`Dart Sass`) implementation. (https://github.com/webpack-contrib/sass-loader#implementation).\",\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        },\n        {\n          \"instanceof\": \"Function\"\n        }\n      ]\n    },\n    \"additionalData\": {\n      \"description\": \"Prepends/Appends `Sass`/`SCSS` code before the actual entry file (https://github.com/webpack-contrib/sass-loader#additionaldata).\",\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"instanceof\": \"Function\"\n        }\n      ]\n    },\n    \"sourceMap\": {\n      \"description\": \"Enables/Disables generation of source maps (https://github.com/webpack-contrib/sass-loader#sourcemap).\",\n      \"type\": \"boolean\"\n    },\n    \"webpackImporter\": {\n      \"description\": \"Enables/Disables default `webpack` importer (https://github.com/webpack-contrib/sass-loader#webpackimporter).\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSassImplementation = getSassImplementation;\nexports.getSassOptions = getSassOptions;\nexports.getWebpackResolver = getWebpackResolver;\nexports.getWebpackImporter = getWebpackImporter;\nexports.getRenderFunctionFromSassImplementation = getRenderFunctionFromSassImplementation;\nexports.normalizeSourceMap = normalizeSourceMap;\nexports.isSupportedFibers = isSupportedFibers;\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _full = require(\"klona/full\");\n\nvar _neoAsync = _interopRequireDefault(require(\"neo-async\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getDefaultSassImplementation() {\n  let sassImplPkg = \"sass\";\n\n  try {\n    require.resolve(\"sass\");\n  } catch (error) {\n    try {\n      require.resolve(\"node-sass\");\n\n      sassImplPkg = \"node-sass\";\n    } catch (ignoreError) {\n      sassImplPkg = \"sass\";\n    }\n  } // eslint-disable-next-line import/no-dynamic-require, global-require\n\n\n  return require(sassImplPkg);\n}\n/**\n * This function is not Webpack-specific and can be used by tools wishing to mimic `sass-loader`'s behaviour, so its signature should not be changed.\n */\n\n\nfunction getSassImplementation(loaderContext, implementation) {\n  let resolvedImplementation = implementation;\n\n  if (!resolvedImplementation) {\n    try {\n      resolvedImplementation = getDefaultSassImplementation();\n    } catch (error) {\n      loaderContext.emitError(error);\n      return;\n    }\n  }\n\n  if (typeof resolvedImplementation === \"string\") {\n    try {\n      // eslint-disable-next-line import/no-dynamic-require, global-require\n      resolvedImplementation = require(resolvedImplementation);\n    } catch (error) {\n      loaderContext.emitError(error); // eslint-disable-next-line consistent-return\n\n      return;\n    }\n  }\n\n  const {\n    info\n  } = resolvedImplementation;\n\n  if (!info) {\n    loaderContext.emitError(new Error(\"Unknown Sass implementation.\"));\n    return;\n  }\n\n  const infoParts = info.split(\"\\t\");\n\n  if (infoParts.length < 2) {\n    loaderContext.emitError(new Error(`Unknown Sass implementation \"${info}\".`));\n    return;\n  }\n\n  const [implementationName] = infoParts;\n\n  if (implementationName === \"dart-sass\") {\n    // eslint-disable-next-line consistent-return\n    return resolvedImplementation;\n  } else if (implementationName === \"node-sass\") {\n    // eslint-disable-next-line consistent-return\n    return resolvedImplementation;\n  }\n\n  loaderContext.emitError(new Error(`Unknown Sass implementation \"${implementationName}\".`));\n}\n/**\n * @param {any} loaderContext\n * @returns {boolean}\n */\n\n\nfunction isProductionLikeMode(loaderContext) {\n  return loaderContext.mode === \"production\" || !loaderContext.mode;\n}\n\nfunction proxyCustomImporters(importers, loaderContext) {\n  return [].concat(importers).map(importer => function proxyImporter(...args) {\n    const self = { ...this,\n      webpackLoaderContext: loaderContext\n    };\n    return importer.apply(self, args);\n  });\n}\n\nfunction isSupportedFibers() {\n  const [nodeVersion] = process.versions.node.split(\".\");\n  return Number(nodeVersion) < 16;\n}\n/**\n * Derives the sass options from the loader context and normalizes its values with sane defaults.\n *\n * @param {object} loaderContext\n * @param {object} loaderOptions\n * @param {string} content\n * @param {object} implementation\n * @param {boolean} useSourceMap\n * @returns {Object}\n */\n\n\nasync function getSassOptions(loaderContext, loaderOptions, content, implementation, useSourceMap) {\n  const options = (0, _full.klona)(loaderOptions.sassOptions ? typeof loaderOptions.sassOptions === \"function\" ? loaderOptions.sassOptions(loaderContext) || {} : loaderOptions.sassOptions : {});\n  const isDartSass = implementation.info.includes(\"dart-sass\");\n\n  if (isDartSass && isSupportedFibers()) {\n    const shouldTryToResolveFibers = !options.fiber && options.fiber !== false;\n\n    if (shouldTryToResolveFibers) {\n      let fibers;\n\n      try {\n        fibers = require.resolve(\"fibers\");\n      } catch (_error) {// Nothing\n      }\n\n      if (fibers) {\n        // eslint-disable-next-line global-require, import/no-dynamic-require\n        options.fiber = require(fibers);\n      }\n    } else if (options.fiber === false) {\n      // Don't pass the `fiber` option for `sass` (`Dart Sass`)\n      delete options.fiber;\n    }\n  } else {\n    // Don't pass the `fiber` option for `node-sass`\n    delete options.fiber;\n  }\n\n  options.file = loaderContext.resourcePath;\n  options.data = loaderOptions.additionalData ? typeof loaderOptions.additionalData === \"function\" ? await loaderOptions.additionalData(content, loaderContext) : `${loaderOptions.additionalData}\\n${content}` : content; // opt.outputStyle\n\n  if (!options.outputStyle && isProductionLikeMode(loaderContext)) {\n    options.outputStyle = \"compressed\";\n  }\n\n  if (useSourceMap) {\n    // Deliberately overriding the sourceMap option here.\n    // node-sass won't produce source maps if the data option is used and options.sourceMap is not a string.\n    // In case it is a string, options.sourceMap should be a path where the source map is written.\n    // But since we're using the data option, the source map will not actually be written, but\n    // all paths in sourceMap.sources will be relative to that path.\n    // Pretty complicated... :(\n    options.sourceMap = true;\n    options.outFile = _path.default.join(loaderContext.rootContext, \"style.css.map\");\n    options.sourceMapContents = true;\n    options.omitSourceMapUrl = true;\n    options.sourceMapEmbed = false;\n  }\n\n  const {\n    resourcePath\n  } = loaderContext;\n\n  const ext = _path.default.extname(resourcePath); // If we are compiling sass and indentedSyntax isn't set, automatically set it.\n\n\n  if (ext && ext.toLowerCase() === \".sass\" && typeof options.indentedSyntax === \"undefined\") {\n    options.indentedSyntax = true;\n  } else {\n    options.indentedSyntax = Boolean(options.indentedSyntax);\n  } // Allow passing custom importers to `sass`/`node-sass`. Accepts `Function` or an array of `Function`s.\n\n\n  options.importer = options.importer ? proxyCustomImporters(Array.isArray(options.importer) ? options.importer : [options.importer], loaderContext) : [];\n  options.includePaths = [].concat(process.cwd()).concat( // We use `includePaths` in context for resolver, so it should be always absolute\n  (options.includePaths || []).map(includePath => _path.default.isAbsolute(includePath) ? includePath : _path.default.join(process.cwd(), includePath))).concat(process.env.SASS_PATH ? process.env.SASS_PATH.split(process.platform === \"win32\" ? \";\" : \":\") : []);\n  return options;\n}\n\nconst MODULE_REQUEST_REGEX = /^[^?]*~/; // Examples:\n// - ~package\n// - ~package/\n// - ~@org\n// - ~@org/\n// - ~@org/package\n// - ~@org/package/\n\nconst IS_MODULE_IMPORT = /^~([^/]+|[^/]+\\/|@[^/]+[/][^/]+|@[^/]+\\/?|@[^/]+[/][^/]+\\/)$/;\n/**\n * When `sass`/`node-sass` tries to resolve an import, it uses a special algorithm.\n * Since the `sass-loader` uses webpack to resolve the modules, we need to simulate that algorithm.\n * This function returns an array of import paths to try.\n * The last entry in the array is always the original url to enable straight-forward webpack.config aliases.\n *\n * We don't need emulate `dart-sass` \"It's not clear which file to import.\" errors (when \"file.ext\" and \"_file.ext\" files are present simultaneously in the same directory).\n * This reduces performance and `dart-sass` always do it on own side.\n *\n * @param {string} url\n * @param {boolean} forWebpackResolver\n * @param {boolean} fromImport\n * @returns {Array<string>}\n */\n\nfunction getPossibleRequests( // eslint-disable-next-line no-shadow\nurl, forWebpackResolver = false, fromImport = false) {\n  let request = url; // In case there is module request, send this to webpack resolver\n\n  if (forWebpackResolver) {\n    if (MODULE_REQUEST_REGEX.test(url)) {\n      request = request.replace(MODULE_REQUEST_REGEX, \"\");\n    }\n\n    if (IS_MODULE_IMPORT.test(url)) {\n      request = request[request.length - 1] === \"/\" ? request : `${request}/`;\n      return [...new Set([request, url])];\n    }\n  } // Keep in mind: ext can also be something like '.datepicker' when the true extension is omitted and the filename contains a dot.\n  // @see https://github.com/webpack-contrib/sass-loader/issues/167\n\n\n  const extension = _path.default.extname(request).toLowerCase(); // Because @import is also defined in CSS, Sass needs a way of compiling plain CSS @imports without trying to import the files at compile time.\n  // To accomplish this, and to ensure SCSS is as much of a superset of CSS as possible, Sass will compile any @imports with the following characteristics to plain CSS imports:\n  //  - imports where the URL ends with .css.\n  //  - imports where the URL begins http:// or https://.\n  //  - imports where the URL is written as a url().\n  //  - imports that have media queries.\n  //\n  // The `node-sass` package sends `@import` ending on `.css` to importer, it is bug, so we skip resolve\n\n\n  if (extension === \".css\") {\n    return [];\n  }\n\n  const dirname = _path.default.dirname(request);\n\n  const normalizedDirname = dirname === \".\" ? \"\" : `${dirname}/`;\n\n  const basename = _path.default.basename(request);\n\n  const basenameWithoutExtension = _path.default.basename(request, extension);\n\n  return [...new Set([].concat(fromImport ? [`${normalizedDirname}_${basenameWithoutExtension}.import${extension}`, `${normalizedDirname}${basenameWithoutExtension}.import${extension}`] : []).concat([`${normalizedDirname}_${basename}`, `${normalizedDirname}${basename}`]).concat(forWebpackResolver ? [url] : []))];\n}\n\nfunction promiseResolve(callbackResolve) {\n  return (context, request) => new Promise((resolve, reject) => {\n    callbackResolve(context, request, (error, result) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nconst IS_SPECIAL_MODULE_IMPORT = /^~[^/]+$/; // `[drive_letter]:\\` + `\\\\[server]\\[sharename]\\`\n\nconst IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\\\]|^\\\\\\\\/i;\n/**\n * @public\n * Create the resolve function used in the custom Sass importer.\n *\n * Can be used by external tools to mimic how `sass-loader` works, for example\n * in a Jest transform. Such usages will want to wrap `resolve.create` from\n * [`enhanced-resolve`]{@link https://github.com/webpack/enhanced-resolve} to\n * pass as the `resolverFactory` argument.\n *\n * @param {Function} resolverFactory - A factory function for creating a Webpack\n *   resolver.\n * @param {Object} implementation - The imported Sass implementation, both\n *   `sass` (Dart Sass) and `node-sass` are supported.\n * @param {string[]} [includePaths] - The list of include paths passed to Sass.\n *\n * @throws If a compatible Sass implementation cannot be found.\n */\n\nfunction getWebpackResolver(resolverFactory, implementation, includePaths = []) {\n  async function startResolving(resolutionMap) {\n    if (resolutionMap.length === 0) {\n      return Promise.reject();\n    }\n\n    const [{\n      possibleRequests\n    }] = resolutionMap;\n\n    if (possibleRequests.length === 0) {\n      return Promise.reject();\n    }\n\n    const [{\n      resolve,\n      context\n    }] = resolutionMap;\n\n    try {\n      return await resolve(context, possibleRequests[0]);\n    } catch (_ignoreError) {\n      const [, ...tailResult] = possibleRequests;\n\n      if (tailResult.length === 0) {\n        const [, ...tailResolutionMap] = resolutionMap;\n        return startResolving(tailResolutionMap);\n      } // eslint-disable-next-line no-param-reassign\n\n\n      resolutionMap[0].possibleRequests = tailResult;\n      return startResolving(resolutionMap);\n    }\n  }\n\n  const isDartSass = implementation.info.includes(\"dart-sass\"); // We only have one difference with the built-in sass resolution logic and out resolution logic:\n  // First, we look at the files starting with `_`, then without `_` (i.e. `_name.sass`, `_name.scss`, `_name.css`, `name.sass`, `name.scss`, `name.css`),\n  // although `sass` look together by extensions (i.e. `_name.sass`/`name.sass`/`_name.scss`/`name.scss`/`_name.css`/`name.css`).\n  // It shouldn't be a problem because `sass` throw errors:\n  // - on having `_name.sass` and `name.sass` (extension can be `sass`, `scss` or `css`) in the same directory\n  // - on having `_name.sass` and `_name.scss` in the same directory\n  //\n  // Also `sass` prefer `sass`/`scss` over `css`.\n\n  const sassModuleResolve = promiseResolve(resolverFactory({\n    alias: [],\n    aliasFields: [],\n    conditionNames: [],\n    descriptionFiles: [],\n    extensions: [\".sass\", \".scss\", \".css\"],\n    exportsFields: [],\n    mainFields: [],\n    mainFiles: [\"_index\", \"index\"],\n    modules: [],\n    restrictions: [/\\.((sa|sc|c)ss)$/i],\n    preferRelative: true\n  }));\n  const sassImportResolve = promiseResolve(resolverFactory({\n    alias: [],\n    aliasFields: [],\n    conditionNames: [],\n    descriptionFiles: [],\n    extensions: [\".sass\", \".scss\", \".css\"],\n    exportsFields: [],\n    mainFields: [],\n    mainFiles: [\"_index.import\", \"_index\", \"index.import\", \"index\"],\n    modules: [],\n    restrictions: [/\\.((sa|sc|c)ss)$/i],\n    preferRelative: true\n  }));\n  const webpackModuleResolve = promiseResolve(resolverFactory({\n    dependencyType: \"sass\",\n    conditionNames: [\"sass\", \"style\"],\n    mainFields: [\"sass\", \"style\", \"main\", \"...\"],\n    mainFiles: [\"_index\", \"index\", \"...\"],\n    extensions: [\".sass\", \".scss\", \".css\"],\n    restrictions: [/\\.((sa|sc|c)ss)$/i],\n    preferRelative: true\n  }));\n  const webpackImportResolve = promiseResolve(resolverFactory({\n    dependencyType: \"sass\",\n    conditionNames: [\"sass\", \"style\"],\n    mainFields: [\"sass\", \"style\", \"main\", \"...\"],\n    mainFiles: [\"_index.import\", \"_index\", \"index.import\", \"index\", \"...\"],\n    extensions: [\".sass\", \".scss\", \".css\"],\n    restrictions: [/\\.((sa|sc|c)ss)$/i],\n    preferRelative: true\n  }));\n  return (context, request, fromImport) => {\n    // See https://github.com/webpack/webpack/issues/12340\n    // Because `node-sass` calls our importer before `1. Filesystem imports relative to the base file.`\n    // custom importer may not return `{ file: '/path/to/name.ext' }` and therefore our `context` will be relative\n    if (!isDartSass && !_path.default.isAbsolute(context)) {\n      return Promise.reject();\n    }\n\n    const originalRequest = request;\n    const isFileScheme = originalRequest.slice(0, 5).toLowerCase() === \"file:\";\n\n    if (isFileScheme) {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        request = _url.default.fileURLToPath(originalRequest);\n      } catch (ignoreError) {\n        // eslint-disable-next-line no-param-reassign\n        request = request.slice(7);\n      }\n    }\n\n    let resolutionMap = [];\n    const needEmulateSassResolver = // `sass` doesn't support module import\n    !IS_SPECIAL_MODULE_IMPORT.test(request) && // We need improve absolute paths handling.\n    // Absolute paths should be resolved:\n    // - Server-relative URLs - `<context>/path/to/file.ext` (where `<context>` is root context)\n    // - Absolute path - `/full/path/to/file.ext` or `C:\\\\full\\path\\to\\file.ext`\n    !isFileScheme && !originalRequest.startsWith(\"/\") && !IS_NATIVE_WIN32_PATH.test(originalRequest);\n\n    if (includePaths.length > 0 && needEmulateSassResolver) {\n      // The order of import precedence is as follows:\n      //\n      // 1. Filesystem imports relative to the base file.\n      // 2. Custom importer imports.\n      // 3. Filesystem imports relative to the working directory.\n      // 4. Filesystem imports relative to an `includePaths` path.\n      // 5. Filesystem imports relative to a `SASS_PATH` path.\n      //\n      // `sass` run custom importers before `3`, `4` and `5` points, we need to emulate this behavior to avoid wrong resolution.\n      const sassPossibleRequests = getPossibleRequests(request, false, fromImport); // `node-sass` calls our importer before `1. Filesystem imports relative to the base file.`, so we need emulate this too\n\n      if (!isDartSass) {\n        resolutionMap = resolutionMap.concat({\n          resolve: fromImport ? sassImportResolve : sassModuleResolve,\n          context: _path.default.dirname(context),\n          possibleRequests: sassPossibleRequests\n        });\n      }\n\n      resolutionMap = resolutionMap.concat( // eslint-disable-next-line no-shadow\n      includePaths.map(context => {\n        return {\n          resolve: fromImport ? sassImportResolve : sassModuleResolve,\n          context,\n          possibleRequests: sassPossibleRequests\n        };\n      }));\n    }\n\n    const webpackPossibleRequests = getPossibleRequests(request, true, fromImport);\n    resolutionMap = resolutionMap.concat({\n      resolve: fromImport ? webpackImportResolve : webpackModuleResolve,\n      context: _path.default.dirname(context),\n      possibleRequests: webpackPossibleRequests\n    });\n    return startResolving(resolutionMap);\n  };\n}\n\nconst MATCH_CSS = /\\.css$/i;\n\nfunction getWebpackImporter(loaderContext, implementation, includePaths) {\n  const resolve = getWebpackResolver(loaderContext.getResolve, implementation, includePaths);\n  return function importer(originalUrl, prev, done) {\n    const {\n      fromImport\n    } = this;\n    resolve(prev, originalUrl, fromImport).then(result => {\n      // Add the result as dependency.\n      // Although we're also using stats.includedFiles, this might come in handy when an error occurs.\n      // In this case, we don't get stats.includedFiles from node-sass/sass.\n      loaderContext.addDependency(_path.default.normalize(result)); // By removing the CSS file extension, we trigger node-sass to include the CSS file instead of just linking it.\n\n      done({\n        file: result.replace(MATCH_CSS, \"\")\n      });\n    }) // Catch all resolving errors, return the original file and pass responsibility back to other custom importers\n    .catch(() => {\n      done({\n        file: originalUrl\n      });\n    });\n  };\n}\n\nlet nodeSassJobQueue = null;\n/**\n * Verifies that the implementation and version of Sass is supported by this loader.\n *\n * @param {Object} implementation\n * @returns {Function}\n */\n\nfunction getRenderFunctionFromSassImplementation(implementation) {\n  const isDartSass = implementation.info.includes(\"dart-sass\");\n\n  if (isDartSass) {\n    return implementation.render.bind(implementation);\n  } // There is an issue with node-sass when async custom importers are used\n  // See https://github.com/sass/node-sass/issues/857#issuecomment-93594360\n  // We need to use a job queue to make sure that one thread is always available to the UV lib\n\n\n  if (nodeSassJobQueue === null) {\n    const threadPoolSize = Number(process.env.UV_THREADPOOL_SIZE || 4);\n    nodeSassJobQueue = _neoAsync.default.queue(implementation.render.bind(implementation), threadPoolSize - 1);\n  }\n\n  return nodeSassJobQueue.push.bind(nodeSassJobQueue);\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9+\\-.]+:/;\n/**\n * @param {string} source\n * @returns {\"absolute\" | \"scheme-relative\" | \"path-absolute\" | \"path-absolute\"}\n */\n\nfunction getURLType(source) {\n  if (source[0] === \"/\") {\n    if (source[1] === \"/\") {\n      return \"scheme-relative\";\n    }\n\n    return \"path-absolute\";\n  }\n\n  if (IS_NATIVE_WIN32_PATH.test(source)) {\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(source) ? \"absolute\" : \"path-relative\";\n}\n\nfunction normalizeSourceMap(map, rootContext) {\n  const newMap = map; // result.map.file is an optional property that provides the output filename.\n  // Since we don't know the final filename in the webpack build chain yet, it makes no sense to have it.\n  // eslint-disable-next-line no-param-reassign\n\n  delete newMap.file; // eslint-disable-next-line no-param-reassign\n\n  newMap.sourceRoot = \"\"; // node-sass returns POSIX paths, that's why we need to transform them back to native paths.\n  // This fixes an error on windows where the source-map module cannot resolve the source maps.\n  // @see https://github.com/webpack-contrib/sass-loader/issues/366#issuecomment-279460722\n  // eslint-disable-next-line no-param-reassign\n\n  newMap.sources = newMap.sources.map(source => {\n    const sourceType = getURLType(source); // Do no touch `scheme-relative`, `path-absolute` and `absolute` types\n\n    if (sourceType === \"path-relative\") {\n      return _path.default.resolve(rootContext, _path.default.normalize(source));\n    }\n\n    return source;\n  });\n  return newMap;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass SassError extends Error {\n  constructor(sassError) {\n    super();\n    this.name = \"SassError\";\n    this.originalSassError = sassError;\n    this.loc = {\n      line: sassError.line,\n      column: sassError.column\n    }; // Keep original error if `sassError.formatted` is unavailable\n\n    this.message = `${this.name}: ${this.originalSassError.message}`;\n\n    if (this.originalSassError.formatted) {\n      this.message = `${this.name}: ${this.originalSassError.formatted.replace(/^Error: /, \"\")}`; // Instruct webpack to hide the JS stack from the console.\n      // Usually you're only interested in the SASS stack in this case.\n\n      this.hideStack = true;\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n}\n\nvar _default = SassError;\nexports.default = _default;"]}